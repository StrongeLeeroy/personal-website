{"data":{"markdownRemark":{"html":"<p>URL shorteners are very useful. Remembering long and tedious URL addresses, or sharing 100 character URLs with your peers is not what we would call, convenient. That's why we have services such as the Google URL Shortener, Bitly or TinyURL.</p>\n<p>We are going to replicate the functionality that these pages offer to some extent. We'll start off by creating an API using Node.js and the Express framework, and will integrate with a MongoDB instance to store information making use of Mongoose.</p>\n<p>The functionality is quite straightforward, we must implement two endpoints in our application:</p>\n<ul>\n<li>/new/URL<em>TO</em>SHORTEN: Creates a new short URL for the provided long URL.</li>\n<li>/SHORT_URL: Will redirect to the long version of the provided short URL.</li>\n<li>Instead of babbling around, let's set up the project and install all of our dependencies.</li>\n</ul>\n<h2>A quick note</h2>\n<p>We are going to use a project structure that is almost identical to the one used for the Request Header Parser Microservice, so feel free to go ahead and check it out if you want to follow along. You can also check out how to use ES6 in Node.js with Babel, as it covers a very similar set-up.</p>\n<p>Once you have a working directory, run npm init as usual, and install the following packages:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"shell\">\n      <pre class=\" cm-s-default\"\n      ><code><span class=\"cm-builtin\">npm</span><span> install </span><span class=\"cm-attribute\">--save</span><span> babel-core babel-register babel-preset-es2015 express mongoose</span></code></pre>\n    </div>\n<p>If you are not familiar with the Babel packages, I recommend that you take a look at this post first. On the other hand, if you're not familiar with Mongoose, take a look at this other article.</p>\n<p>Once everything is set up, create your entry index.js file:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\" cm-s-default\"\n      ><code><span class=\"cm-variable\">require</span><span>(</span><span class=\"cm-string\">'babel-register'</span><span>);\n\n</span><span class=\"cm-keyword\">const</span><span> </span><span class=\"cm-def\">app</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">require</span><span>(</span><span class=\"cm-string\">'./src/app'</span><span>).</span><span class=\"cm-property\">app</span><span>,\n</span><span>      </span><span class=\"cm-def\">PORT</span><span> </span><span class=\"cm-operator\">=</span><span> </span><span class=\"cm-variable\">process</span><span>.</span><span class=\"cm-property\">env</span><span>.</span><span class=\"cm-property\">PORT</span><span> </span><span class=\"cm-operator\">||</span><span> </span><span class=\"cm-number\">8000</span><span>;\n\n</span><span class=\"cm-variable\">app</span><span>.</span><span class=\"cm-property\">listen</span><span>(</span><span class=\"cm-variable\">PORT</span><span>,</span><span> </span><span class=\"cm-keyword\">function</span><span>()</span><span> </span><span>{\n</span><span>\t</span><span class=\"cm-variable\">console</span><span>.</span><span class=\"cm-property\">log</span><span>(</span><span class=\"cm-string\">'URL shortener microservice listening on port'</span><span>,</span><span> </span><span class=\"cm-variable\">PORT</span><span>);\n});</span></code></pre>\n    </div>\n<p>And create the main app file in the src directory. I'll setup a basic express app:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import express from 'express';\n\nexport const app = express();</span></code></pre>\n    </div>\n<hr>\n<h2>App architecture</h2>\n<p>Out app will work as follows: we'll define two endpoints as mentioned above. The <code>/new/LONG_URL</code> endpoint will take in a URL, and create a MongoDB entry with a short code that we will assign for reference. It should be smart enough to know if the URL is valid, or if that particular URL has already been made short.</p>\n<p>We're going to keep it simple, the code is going to be a number that we'll increment as we add more URLs to the database. Here's an example:</p>\n<p>Calling /new/<a href=\"https://www.google.com\">https://www.google.com</a> should insert the following document:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"json\">\n      <pre class=\" cm-s-default\"\n      ><code><span>{\n  \"original\": \"https://www.google.com\",\n  \"shortCode\": 0\n}</span></code></pre>\n    </div>\n<p>And return this message:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-default\"\n      ><code><span>Url successfully shortened: http://www.example.com/0</span></code></pre>\n    </div>\n<p>Calling that same endpoint again should not insert any documents and return the following message:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"json\">\n      <pre class=\" cm-s-default\"\n      ><code><span>{\n  \"error\": \"URL already exists in the database.\",\n  \"url\": \"http://www.example.com/0\"\n}</span></code></pre>\n    </div>\n<p>Using an invalid URL such as <code>/new/thisisnotaurl</code> should return an error:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"json\">\n      <pre class=\" cm-s-default\"\n      ><code><span>{\n  \"error\": \"Invalid URL format. Input URL must comply to the following: http(s)://(www.)domain.ext(/)(path)\"\n}</span></code></pre>\n    </div>\n<p>Another valid URL will increment the code by one in the inserted document:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"json\">\n      <pre class=\" cm-s-default\"\n      ><code><span>{\n  \"original\": \"https://www.twitter.com\",\n  \"shortCode\": 1\n}</span></code></pre>\n    </div>\n<p>The other endpoint, will simply take a number and redirect to the original URL. E.g.: navigating to: /1 should redirect your browser to <a href=\"https://www.twitter.com\">https://www.twitter.com</a>. If the provided code does not exists in the database, we'll return an error.</p>\n<hr>\n<h2>Mongoose Schema</h2>\n<p>We're going to be using Mongoose to simplify communication with MongoDB. We only need to create one schema, as we are only going to be storing original URL - shortened URL pairs in our URL shortener as shown in the examples above.</p>\n<p>Open up app.js, and let's get dirty:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import express from 'express';\nimport mongoose from 'mongoose'; // Import mongoose\n\nexport const app = express();\n\n// Use NodeJS promises instead of built in ones\n// We only do this because the promise library\n// in mongoose is now deprecated.\nmongoose.Promise = global.Promise;\n\n// Connect to your MongoDB instance and chosen collection\nmongoose.connect('mongodb://localhost:27017/urlShortener');\n\n// Set up the urlEntry schema\nvar urlSchema = mongoose.Schema({\n  original: String,\n  shortCode: { type: Number, index: true }\n});\n\n// I create an index here so it's faster to search by shortCode\nurlEntrySchema.index({ shortCode: 1 });\n\n// Now, I create the model:\nvar UrlEntry = mongoose.model('UrlEntry', urlEntrySchema);\nThat's it for mongoose set up, onto the endpoints themselves.</span></code></pre>\n    </div>\n<h2>Endpoint: /new</h2>\n<p>As seen in previous posts, you can user path parameters to send data through to the endpoint handler doing something like this:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>app.get('/new/:longUrl', (req, res) => {\n  // longUrl is accessible here:\n  console.log(req.params.longUrl);\n});</span></code></pre>\n    </div>\n<p>The problem here, is that URLs contain slash characters within, and the path parsing in Express is going to get confused if we pass in stuff like this:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"null\">\n      <pre class=\" cm-s-default\"\n      ><code><span>/new/http://www.awebsite.com/blog/post-name-here</span></code></pre>\n    </div>\n<p>Why? Because we are not going to hit /new/:longUrl. There is more than one path parameter there:</p>\n<p><code>/new</code></p>\n<ul>\n<li>/http:</li>\n<li>/</li>\n<li>/www.awebsite.com</li>\n<li>/blog</li>\n<li>/post-name/here</li>\n</ul>\n<p>So, what do we do? It's simple enough, instead of fixed, named path parameters, we'll use a wildcard like so:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>app.get('/new/*', (req, res) => {\n  // Whatever follows /new is accessible at req.params[0]\n  console.log(req.params[0]);\n});</span></code></pre>\n    </div>\n<p>Having this knowledge, we can now implement our endpoint with the following logic:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import ...\n\n// Mongoose stuff\n\napp.get('/new/*', (req, res) => {\n  let url = req.params[0];\n  if (isValidUrl(url)) {  // We'll write this function shortly\n    // We check for duplicates here, if the URL has already been\n    // shortened, we return the existing entry, otherwise, we create a new\n    // entry and return it.\n  } else {\n    res.status(500).json({ error: 'Invalid URL format. Input URL must comply to the following: http(s)://(www.)domain.ext(/)(path)' });\n  }\n});</span></code></pre>\n    </div>\n<h2>Helper function: isValidUrl()</h2>\n<p>The isValidUrl function used above will look like so:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>function isValidUrl(url) {\n  // Must comply to this format () means optional:\n  // http(s)://(www.)domain.ext(/)(whatever follows)\n  let regEx = /^https?://(S+.)?(S+.)(S+)S*/;\n  return regEx.test(url);\n}</span></code></pre>\n    </div>\n<p>It's a pretty simple method, it simply tests for a not-too-strict URL format and returns true or false based on the test. You can learn more about regular expressions here.</p>\n<p>Feel free to add it to the app.js file itself, or define it in an external file and import it.</p>\n<p>We now need to check for duplicates, we can do so using an external function that takes advantage of the Mongoose model we created, it will take in the long URL and return false if the URL does not already exists in the database, or the short code if it does:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>function isDuplicate(url) {\n  return UrlEntry\n    .findOne({ original: url })\n    .then(doc => {\n      return doc ? doc.shortCode : false;\n    });\n}</span></code></pre>\n    </div>\n<p>This function returns something that looks like a Promise. We can asynchronously perform this query and wait for the result in the endpoint defined above:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import ...\n\n// Mongoose stuff\n\napp.get('/new/*', (req, res) => {\n  let url = req.params[0];\n  if (isValidUrl(url)) {\n    isDuplicate(url).then(shortCode => {\n      if (shortCode) {\n        res.status(200).json({\n          error: 'URL already exists in the database.'\n          url: `http://www.example.com/${shortCode}`\n        });\n      } else {\n        // If it's not a duplicate, we insert a new document here.\n      }\n    });\n  } else {\n    res.status(500).json({ error: 'Invalid URL format. Input URL must comply to the following: http(s)://(www.)domain.ext(/)(path)' });\n  }\n});\n\nfunction isValidUrl(url) { /* ... */ }\nfunction isDuplicate(url) { /* ... */ }</span></code></pre>\n    </div>\n<p>We no need to insert a new document in the database. This is a two step process, we need to generate a new code for the entry before saving anything, and it must not be repeated.</p>\n<p>The flow is as follows:</p>\n<ol>\n<li>Look for the entry with the highest code in the database.</li>\n<li>Add 1 to it.</li>\n<li>Save the new entry with the incremented code.</li>\n</ol>\n<p>To make it a bit less confusing, we'll write two functions:</p>\n<ul>\n<li><code>getShortCode()</code>: Will return a new code for us to use.</li>\n<li><code>insertNew(url)</code>: will call getShortCode within and insert a new document for the given URL.</li>\n</ul>\n<p>Here we go for <code>getShortCode</code>:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>function getShortCode() {\n  return UrlEntry\n    .find()  // We search without criteria\n    .sort({ shortCode: -1 }) // We sort by shortCode DESCENDING\n    .limit(1)  // We only return the FIRST\n    .select({ _id: 0, shortCode: 1 }) // We only return the shortCode field\n    .then(docs => {\n      // If a document is found, we return it's shortCode plus one,\n      // otherwise, we return 0, as it means there are no documents,\n      // and this is the first\n      return docs.length === 1 ? docs[0].shortCode + 1 : 0;\n    });\n}</span></code></pre>\n    </div>\n<p>Basically, we did an empty find() so every document is matched, and then ordered them so that the highest shortCode is first, and limit it so we only get that one.</p>\n<p>Moving onto insertNew:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>function insertNew(url) {\n  // We get a new code from getShortCode first\n  // It returns a promise as it's an asynchronous action\n  return getShortCode().then(newCode => {\n    // We create a new UrlEntry using the mongoose model\n    let newUrl = new UrlEntry({ original: url, shortCode: newCode });\n    // We return the promise generated by save()\n    return newUrl.save();\n  });\n}</span></code></pre>\n    </div>\n<p>We can now finally add this final piece to our endpoint:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import ...\n\n// Mongoose stuff\n\napp.get('/new/*', (req, res) => {\n  let url = req.params[0];\n  if (isValidUrl(url)) {\n    isDuplicate(url).then(shortCode => {\n      if (shortCode) {\n        res.status(200).json({\n          error: 'URL already exists in the database.'\n          url: `http://www.example.com/${shortCode}`\n        });\n      } else {\n        insertNew(url).then(insertedDocument => {  // save() gives us the inserted document to use\n          if (!insertedDocument) {\n            res.status(500).json({ error: 'Unknown error' }); // Something failed for some reason.\n          } else {\n            res.status(200).send(`URL successfully shortened: http://www.example.com/${insertedDocument.shortCode}`); // We return the shortened URL\n          }\n        });\n      }\n    });\n  } else {\n    res.status(500).json({ error: 'Invalid URL format. Input URL must comply to the following: http(s)://(www.)domain.ext(/)(path)' });\n  }\n});\n\nfunction isValidUrl(url) { /* ... */ }\nfunction isDuplicate(url) { /* ... */ }\nfunction getShortCode(url) { /* ... */ }\nfunction insertNew(url) { /* ... */ }</span></code></pre>\n    </div>\n<p>Our endpoint is complete. It can now shorten URLs and will check for invalid or duplicate values. We now need an additional endpoint that will take in a shortCode and redirect the user to the original URL.</p>\n<hr>\n<h2>Endpoint: Redirection</h2>\n<p>This one is easier than the previous. We are going to make use of the redirect() method provided by Express.  First though, we need to check if the provided shortCode is valid (is it a number?) and if there is an entry in the database with said code:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import ...\n\n// Mongoose stuff\n\napp.get('/:shortCode', (req, res) -> {\n  let shortCode = parseInt(req.params.shortCode); // We parse the input code\n  if (isNaN) { // It's not a number :(\n    res.status(500).json({ error: 'Invalid URL shortCode. It must be a number.' })\n  } else {\n    UrlEntry.findOne({ shortCode }).then(doc => {\n      if (!doc) { // It does not exist as there is no result\n        res.status(404).json({ error: 'Page not found' });\n      } else { // It exists, we use redirect on the response with the original URL as argument\n        res.redirect(doc.original);\n      }\n    });\n  }\n});\n\napp.get('/new/*', (req, res) => { /* ... */ });\n\n// Additional functions go here...</span></code></pre>\n    </div>\n<p>And there we go. This should set you up for success, there is a little issue though, we have hardcoded the domain for the shortened URL that we are returning. Let's create a new function so that our URL shortener returns a more dynamic result based on the domain that it lives in:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>function createFullUrl(req, shortCode) {\n  return `${req.protocol}://${req.hostname}:${getPort()}/${shortCode}`;\n}\n\nfunction getPort() {\n  return process.env.PORT || 8000;\n}</span></code></pre>\n    </div>\n<p>This method takes in the request object and a shortCode, and returns a URL in the following format: <a href=\"http://www.example.com/1000\">http://www.example.com/1000</a></p>\n<h2>The URL shortener</h2>\n<p>Let's put all of this together and add some import/export goodness to it.</p>\n<p>I'm only going to tidy up out URL shortener microservice and move most functions to external files that I'll then import into our endpoints. I'm also going to move the Mongoose schema logic out of the main file. Here's the end result:</p>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>require('babel-register');\n\nconst app = require('./src/app').app,\n      PORT = process.env.PORT || 8000;\n\napp.listen(PORT, function() {\n  console.log('URL shortener microservice listening on port', PORT);\n});</span></code></pre>\n    </div>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import express from 'express';\nimport mongoose from 'mongoose';\n\nimport { UrlEntry } from './urlEntry';\nimport { createFullUrl, isValidUrl } from './url-utils';\nimport { getShortCode, isDuplicate, insertNew } from './mongo-utils';\n\nmongoose.Promise = global.Promise;\n\nexport const app = express();\nmongoose.connect('mongodb://localhost:27017/urlShortener');\n\napp.get('/:shortCode', (req, res) => {\n  let shortCode = parseInt(req.params.shortCode);\n  if (isNaN(shortCode)) {\n    res.status(200).json({ error: 'Invalid URL shortCode. It must be a number.' })\n  } else {\n    UrlEntry.findOne({ shortCode }).then(doc => {\n      if (!doc) {\n        res.status(404).json({ error: 'Page not found' });\n      } else {\n        res.redirect(doc.original);\n      }\n    });\n  }\n});\n\napp.get('/new/*', (req, res) => {\n  let url = req.params[0];\n  if (isValidUrl(url)) {\n    isDuplicate(url).then(exists => {\n      if (exists) {\n        res.status(500).json({ error: 'URL already exists in the database.', shortCode: exists });\n      } else {\n        insertNew(url).then(inserted => {\n          res.status(200).json({ message: 'Url successfully shortened', url: createFullUrl(req, inserted.shortCode) });\n        });\n      }\n    });\n  } else {\n    res.status(500).json({ error: 'Invalid URL format. Input URL must comply to the following: http(s)://(www.)domain.ext(/)(path)'});\n  }\n});</span></code></pre>\n    </div>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>export function isValidUrl(url) {\n  // Must comply to this format () means optional:\n  // http(s)://(www.)domain.ext(/)(whatever follows)\n  let regEx = /^https?://(S+.)?(S+.)(S+)S*/;\n  return regEx.test(url);\n}\n\nexport function createFullUrl(req, url) {\n  return `${req.protocol}://${req.hostname}:${getPort()}/${url}`;\n}\n\nfunction getPort() {\n  return process.env.PORT || 8000;\n}</span></code></pre>\n    </div>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import { UrlEntry } from './urlEntry';\n\nexport function getShortCode() {\n  return UrlEntry\n    .find()\n    .sort({ shortCode: -1 })\n    .limit(1)\n    .select({ _id: 0, shortCode: 1 })\n    .then(docs => {\n      return docs.length === 1 ? docs[0].shortCode + 1 : 0;\n    });\n}\n\nexport function isDuplicate(url) {\n  return UrlEntry\n    .findOne({ original: url})\n    .then(doc => doc ? doc.shortCode : false );\n}\n\nexport function insertNew(url) {\n  return getShortCode().then(newCode => {\n    let newUrl = new UrlEntry({ original: url, shortCode: newCode });\n    return newUrl.save();\n  });\n}</span></code></pre>\n    </div>\n\n    <div class=\"gatsby-highlight\" data-language=\"js\">\n      <pre class=\" cm-s-default\"\n      ><code><span>import mongoose from 'mongoose';\n\nvar urlEntrySchema = mongoose.Schema({\n  original: String,\n  shortCode: { type: Number, index: true }\n});\nurlEntrySchema.index({ shortCode: 1 });\nurlEntrySchema.set('autoIndex', false);\n\nexport var UrlEntry = mongoose.model('UrlEntry', urlEntrySchema);</span></code></pre>\n    </div>\n<p>Your <strong>URL shortener</strong> is ready to go and start shortening stuff. You can now take this project a step further and implement a proper front end for it. Then, deploy it so the whole internet can use it!</p>\n<p>Do get in touch and let me know of your queries or concerns. Stay tuned.</p>","frontmatter":{"title":"Create a URL Shortener with Node.js and MongoDB","date":"May 14, 2019","author":"Gorka Hernández Estomba","category":["Node.js","Beginner Series"],"tags":["API","Array Methods","backend","developer","ECMAScript 2015","ECMAScript 6","endpoint","ES2015","ES6","express","express.js","expressjs","FreeCodeCamp","GET","JavaScript","MongoDB","mongoose","mongoose.js","mongoosejs","Node.js","nodejs","node","npm","regex","regexp","solution","solutions","ternary"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2019/05/14/create-url-shortener-nodejs-mongodb"}}